import pytest
from unittest.mock import MagicMock, call # call for checking multiple calls if needed
from sqlalchemy import select # To help construct expected statements

from app.repositories.user_repository import UserRepository
from app.models.user_model import User # For type hinting and constructing expected objects

# Sample user data for mocking repository responses
sample_users_data = [
    {"id": 1, "username": "johndoe", "email": "john.doe@example.com", "first_name": "John", "last_name": "Doe"},
    {"id": 2, "username": "janedoe", "email": "jane.doe@example.com", "first_name": "Jane", "last_name": "Doe"},
    {"id": 3, "username": "peters", "email": "peter.s@example.com", "first_name": "Peter", "last_name": "Smith"},
    {"id": 4, "username": "smithy", "email": "s.smith@example.com", "first_name": "Sarah", "last_name": "Smithy"},
]

@pytest.fixture
def mock_db_session():
    """Fixture for a mock SQLAlchemy session."""
    session = MagicMock()
    # Mock the chain of calls: session.execute(...).scalars().all()
    mock_scalars = MagicMock()
    
    # Set up default return value for scalars().all()
    # This can be overridden in specific tests if needed
    mock_users = [User(**data) for data in sample_users_data]
    mock_scalars.all.return_value = mock_users
    
    session.execute.return_value.scalars.return_value = mock_scalars
    return session

@pytest.fixture
def user_repository(mock_db_session):
    """Fixture for UserRepository instance with a mocked session."""
    return UserRepository(mock_db_session)

def test_get_users_by_name_criteria_no_params(user_repository, mock_db_session):
    """
    Test get_users_by_name_criteria with no parameters.
    Should return all users (as per current mock_db_session setup).
    """
    result = user_repository.get_users_by_name_criteria()

    mock_db_session.execute.assert_called_once()
    executed_statement = mock_db_session.execute.call_args[0][0]
    
    # Check that the base select statement for User model was used
    # and no WHERE clauses were added
    assert str(executed_statement).startswith(str(select(User)))
    assert "WHERE" not in str(executed_statement).upper()
    
    assert len(result) == len(sample_users_data) # Assuming mock returns all sample users

def test_get_users_by_name_criteria_first_name_starts_with(user_repository, mock_db_session):
    """Test filtering by first_name_starts_with only."""
    prefix = "Jo"
    # Example: Configure mock to return specific users for this query if needed
    # For now, we focus on the query construction.
    
    user_repository.get_users_by_name_criteria(first_name_starts_with=prefix)

    mock_db_session.execute.assert_called_once()
    executed_statement = mock_db_session.execute.call_args[0][0]
    
    # Verify the WHERE clause
    # Note: Comparing SQLAlchemy statement objects directly can be complex.
    # We'll check the string representation for simplicity.
    # This is a bit brittle but good enough for this context.
    # A more robust way would be to use a library or helper to parse SQL.
    
    expected_sql_fragment = str(User.first_name.ilike(f"{prefix}%")).upper()
    # The actual SQL generated by SQLAlchemy might be slightly different based on dialect,
    # so we check for key components.
    
    executed_sql_upper = str(executed_statement).upper()
    assert "WHERE" in executed_sql_upper
    # This assertion for SQL fragment is tricky because of quoting and dialect.
    # A simplified check for column name and pattern:
    assert "USERS.FIRST_NAME" in executed_sql_upper
    assert f"'{prefix.upper()}%'" in executed_sql_upper # Assuming uppercase and simple quotes
    assert "ILIKE" in executed_sql_upper # or LIKE depending on DB

def test_get_users_by_name_criteria_last_name_ends_with(user_repository, mock_db_session):
    """Test filtering by last_name_ends_with only."""
    suffix = "oe"
    user_repository.get_users_by_name_criteria(last_name_ends_with=suffix)

    mock_db_session.execute.assert_called_once()
    executed_statement = mock_db_session.execute.call_args[0][0]
    executed_sql_upper = str(executed_statement).upper()

    assert "WHERE" in executed_sql_upper
    assert "USERS.LAST_NAME" in executed_sql_upper
    assert f"'%{suffix.upper()}'" in executed_sql_upper
    assert "ILIKE" in executed_sql_upper

def test_get_users_by_name_criteria_both_params(user_repository, mock_db_session):
    """Test filtering by both first_name_starts_with and last_name_ends_with."""
    prefix = "Ja"
    suffix = "oe"
    user_repository.get_users_by_name_criteria(first_name_starts_with=prefix, last_name_ends_with=suffix)

    mock_db_session.execute.assert_called_once()
    executed_statement = mock_db_session.execute.call_args[0][0]
    executed_sql_upper = str(executed_statement).upper()

    assert "WHERE" in executed_sql_upper
    assert "USERS.FIRST_NAME" in executed_sql_upper
    assert f"'{prefix.upper()}%'" in executed_sql_upper
    assert "USERS.LAST_NAME" in executed_sql_upper
    assert f"'%{suffix.upper()}'" in executed_sql_upper
    assert "AND" in executed_sql_upper # Both conditions should be ANDed
    assert "ILIKE" in executed_sql_upper

def test_get_users_by_name_criteria_no_results(user_repository, mock_db_session):
    """Test filtering with criteria that should yield no results (mocked)."""
    # Configure mock to return an empty list for this specific query's parameters
    mock_db_session.execute.return_value.scalars.return_value.all.return_value = []
    
    prefix = "NonExistentName"
    result = user_repository.get_users_by_name_criteria(first_name_starts_with=prefix)

    mock_db_session.execute.assert_called_once()
    executed_statement = mock_db_session.execute.call_args[0][0]
    executed_sql_upper = str(executed_statement).upper()

    assert "WHERE" in executed_sql_upper
    assert "USERS.FIRST_NAME" in executed_sql_upper
    assert f"'{prefix.upper()}%'" in executed_sql_upper
    
    assert len(result) == 0

# Note on SQL assertion:
# Asserting exact SQL string is generally fragile due to differences in how SQLAlchemy
# renders for various dialects, whitespace, quoting, etc.
# A better approach for complex queries might involve:
# 1. Using a library that can parse and compare SQL abstract syntax trees.
# 2. Mocking the `ColumnOperators.ilike` method itself to see if it's called with the right pattern.
#    Example: `with patch.object(User.first_name, 'ilike') as mock_ilike:`
#             `user_repository.get_users_by_name_criteria(first_name_starts_with="Test")`
#             `mock_ilike.assert_called_with("Test%")`
# For this task, string checking for key components (WHERE, column name, pattern, ILIKE) is used as a simpler proxy.
# The actual test for `ilike` behavior is usually done at the SQLAlchemy level or integration tests.
# The primary goal here is to check if the repository *attempts* to build the correct type of query.
# The current SQL checks are very basic and might need adjustment if they are too brittle.
# For example, the quoting of patterns (`'{prefix.upper()}%'`) can vary.
# A more robust check for the pattern argument to ilike would be to capture the statement,
# then inspect its `whereclause` attribute if possible, though this gets into SQLAlchemy internals.

# A helper for more robust SQL checking (conceptual):
# def assert_sql_has_ilike_clause(statement, column_name, pattern):
#     # This would need to parse the statement's compiled form for the specific dialect
#     # or inspect its internal structure.
#     compiled_stmt = statement.compile(compile_kwargs={"literal_binds": True}) # Example
#     # print(str(compiled_stmt)) # For debugging
#     # Then check str(compiled_stmt) for `column_name ILIKE 'pattern'`
#     pass

# For the ILIKE pattern check, it's more reliable to check the parameters passed to ilike
# if we were to mock the ilike method on the column object, rather than stringifying the whole query.
# However, the current tests check that the execute method is called with *some* statement,
# and then make broad assertions on the stringified version of that statement.
# This is a common balance in unit testing repositories.
print("test_user_repository.py created with basic tests.")
